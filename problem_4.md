
##  Movie Recommendation 

This task is to combine the matrix in task 1 and formula in task 3 to implement a primitive movie recommendation system. Make sure to finish task 1 and 3 completely before starting this task.

### Design

The mathematical theory behind this task is called "collaborative filtering." We won't dive too much into the theory, but here's how it works in our system:

#### User-genre Matrix

- Users would make rating between 1-5 (1 being the least favorite, and 5 being the highest) to the following movie genres:
  - Documentary
  - Drama
  - Comedy
  - Noir
The rating is expressed in a matrix *A* (also called 'user-genre' in the code) such as:

Each row represents what a user likes to which extent. For example, user 2 (row 2) doesn't like comedy (rating of 1), but likes drama slightly more (4 vs 3) than documentary.

#### Genre-feature Matrix

- Our recommendation system maintains a matrix *B* that rates features of each genre in the following categories between 0 and 1 (0 being the least relevant, and 1 being the highest):

  - Historical
  - Excitement
  - Humor
  - Emotional
  - Mystery
  - Action

This genre vs feature matrix looks like this:


[Here](https://github.com/a-teaching-goose/2024-summer-342-hw-2/blob/main/src/task_4/movie_recommender.hpp#L21)'s how it's stored in the code.

#### Featrue-movie Matrix

Lastly, a set of movies is rated between 0 and 1 (0 being the least relevant, and 1 being the highest) with the features in the third matrix *C* as follows:


#### Movie Recommendation

Give the three matrices *A*, *B* and *C*, the recommendation matrix is generated by multiplying the three matrices together:

*D = A x B x C*

This matrix multiply is implemented [here](https://github.com/a-teaching-goose/2024-summer-342-hw-2/blob/main/src/task_4/movie_recommender.hpp#L61) using the Matrix and Formula class from previous tasks. In the resulted matrix, each row represents recommendation rating for a user, and the column that has the highest rating in matrix D is the movie. See the [unit tests](https://github.com/a-teaching-goose/2024-summer-342-hw-2/blob/main/test/unit_test_task_4.cpp#L60) for some examples.

### Task

Finish the code in [this section](https://github.com/a-teaching-goose/2024-summer-342-hw-2/blob/main/src/task_4/movie_recommender.hpp#L64). In the code, we calculate the rating one user at a time. Therefore the matrix *A* is always 1 row by 4 columns. And as a result matrix *D* is always 1 row 5 columns. For example

```
user-genre matrix (A)
0.50 0.50 5.00 0.50

genre-feature matrix (B)
1.00 0.20 0.10 0.70 0.10 0.20 
0.20 0.70 0.20 0.90 0.40 0.40 
0.20 0.70 1.00 0.50 0.20 0.20 
0.30 0.50 0.10 0.60 0.80 0.30

feature-movie matrix (C)
1.00 0.20 0.80 0.10 0.20 
0.40 1.00 0.40 0.50 0.50 
0.20 0.20 0.30 0.50 1.00 
0.80 0.40 1.00 0.80 0.70 
0.30 0.50 0.20 0.40 0.20 
0.40 1.00 0.30 0.60 0.20

recommendation matrix (D)
8.43 9.30 9.01 9.28 10.79 
```

The largest value is (zero-based) column 4, value of 10.79, which in turn selects movie 5 (index 4) "movie 5 - Seinfeld" from the movies vector as the recommendation pick
```c++
User user1("user 1, who loves comedy",
               {
                       {"documentary", 0.5},
                       {"drama",       0.5},
                       {"comedy",      5.0},
                       {"noir",        0.5},
               });

    Movie actual = recommender.recommend(user1);
    ASSERT_EQ(movies[4], actual);
```

### Note
- This task relies on code from task 1 and 3 to be completely finished.
- The example in this task is a very primitive recommendation system. The recommendation is a bit sensitive to values in the three matrices. The goal is just to illustrate an actual application that uses matrix multiplication.
- A bit more info on collaborative filtering: https://developers.google.com/machine-learning/recommendation/collaborative/basics.
